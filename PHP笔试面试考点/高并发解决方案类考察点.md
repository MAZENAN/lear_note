- [1.高并发架构相关概念](#gn)
- [2.高并发解决方案案例](#al)
- [3.高并发方案详细说明](#sm)
# <a id="gn">高并发架构相关概念</a>  
1. __什么是高并发：__  
在互联网时代，所讲的并发、高并发，通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。通常如果一个系统的日PV在千万以上，有可能是一个高并发的系统，有的公司完全不走技术路线，全靠机器堆，这不在我们的讨论范围内。  
2.  __高并发的问题我们具体该关心什么？__  
__QPS__: 每秒钟请求或者查询的数量，在互联网领域，指的是每秒响应请求数（指的是HTTP请求）;  
__吞吐率__: 单位时间内服务器处理的请求数量，通常使用“reqs/s”来表示。我们关心的是最大吞吐率（通常由QPS与并发数决定）  
__响应时间__: 从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms,这个100ms就是系统的响应时间。  
__PV__: 综合浏览量(Page View),即页面浏览量或者点击量，一个访客在24小时内访问的页面数量。同一个人浏览你的网站的同一页面，只记作一次PV。 多次刷新同一页面只算一次。根据日均pv可以计算出峰值qps.   
__UV__: 独立访客（Unique Visitor）,即一定时间范围内相同访客多次访问网站，只计算为1个独立访客。  
__带宽__:计算带宽大小需要关注两个指标，峰值流量和页面的平均大小
    >     日网站带宽 = PV/统计时间（换算到秒）*平均页面大小（单位KB）*8
    >     峰值一般是平均值的倍数，根据实际情况来定  

    >     注意：QPS不等于并发连接数；QPS是每秒HTTP请求的数量，并发连接数是系统同时处理请求数量。 

    >     峰值每秒请求数（QPS）= （总PV数*80%）*（6小时秒数*20%）
    >     80%的访问量集中在20%的访问时间  
2.  __压力测试:__  
__常用性能测试工具__ ：ab、wrk、http_load、Web Bench、Siege、Apache JMeter  
__ab__ :全称是apache benchmark,是apache官方推出的工具创建多个并发访问线程，模拟多个访问者同时对某一个URL地址进行访问。它的测试目标基于URL，因此它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其他Web服务器的压力。  
__ab的使用__ :模拟并发请求100次，总共请求5000次。  
    >     ab -c 100 -n 5000 待测试的网站

__ab使用注意事项__ : 测试机器与被测试机器分开；不要对线上服务做压力测试；观察测试工具ab所在的机器，以及被测试的前下·端机的CPU，内存，网络等都不超过最高限度的75%。  
__QPS达到极限__：  
随着QPS的增长，每个阶段的需要根据实际情况来进行优化，优化的方案也与硬件条件、网络带宽息息相关。  
__QPS达到50__：  
可以称之为小型网站，一般的服务器就可以应付。  
__QPS达到100__：  
假设关系型数据库每次请求在0.01秒完成。假设单个页面只有一个SQL查询，那么100QPS意味着1秒钟完成100次请求，但是此时我们并不能保证数据库查询能完成100次。  
方案：数据库缓存层、数据库的负载均衡。  
__QPS达到800__：  
假设我们使用百兆带宽，意味着网站出口的实际带宽是8M左右，假设每个页面只有10K，在这个并发条件下，百兆带宽已经吃完。  
方案：CDN加速、负载均衡。   
__QPS达到1000__：  
假设使用Memcache缓存数据库查询数据，每个页面对Memcache的请求远大于直接对DB的请求；Memcache的悲观并发数在2w左右，但有可能在之前内网带宽已经吃光，表现出不稳定。  
方案：静态HTML缓存。  
__QPS达到2000__：  
这个级别下，文件系统访问锁都成了灾难。  
方案：做业务分离，分布式存储。  
# <a id="al">高并发解决方案案例</a>   
1. __流量优化__  
防盗链处理  
2. __前端优化__  
减少http请求（例如合并js、css文件）  
添加异步请求（不要一次请拿到数据） 
启用浏览器缓存和文件压缩  
CDN加速（就近访问，解决带宽不够用问题）  
建立独立的图片服务器(吃io,针对性优化（磁盘优化）)  
3. __服务端优化__  
页面静态化（直接缓存成html页面）  
（穿透了静态化、实时性要求比较高）并发处理(多线程进程异步处理、队列处理)  
4. __数据库优化__  
数据库缓存  
分库分表、分区操作  
读写分离  
负载均衡  
5. __Web服务器优化__  
负载均衡  
# <a id="sm">高并发方案详细说明</a>  
1. Web资源防盗链  
2. 减少HTTP请求次数  
__为什么减少HTTP请求__：  
__(1)性能黄金法则：__只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下80%-90%的时间花在HTML文档所引用的所有组件（图片，script,css,flash等等） 进行的HTTP请求上。  
__(2)如何改善:__改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量。  
__(3)HTTP连接产生的开销：__域名解析--TCP连接--发送请求--等待--下载资源--解析时间。  
__(4)疑问？__DNS缓存；Keep-Alive。  
__(5)打破谣言:__查找DNS缓存也需要时间，多个缓存就要查找多次有可能缓存被清除。HTTP1.1协议规定请求只能串行发送，也就是一百个请求必须逐个发送，前面一个请求完成才能开始下一个请求。  
__减少HTTP请求的方式__  
__(1)图片地图:__图片地图允许你在一个图片上关联多个URL。目标URL的选择取决于用户单击了图片上的哪个位置。将n个图片合为一张图片，然后以位置信息定位超链接把HTTP请求减少为一个，可以保证设计的完整性和功能的齐全性。  
使用`<map><area></area></map>`标签  
![语法](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/img_map.png)  
__(2)CSS Sprites:__中文翻译为CSS精灵，通过使用合并图片，通过指定css的background-image和background-position来显示元素。  
__background-position属性：__  
background-position:x y;x和y可以写负值也可以写正值,我们可以想象图片的左上方为(0,0),以(0,0)坐标向右是为负数的x轴,以(0,0)坐标向下为负数的y轴。  
![坐标](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/zuobiao.png)  
使用案例：  
![精灵使用1](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/jl1.png)   
![精灵使用2](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/jl2.png)   
![精灵使用3](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/jl3.png)   


__性能影响：__图片地图与CSS精灵的响应时间基本相同，但比使用各自独立图片的方式要快50%以上。  
__(3)合并脚本和样式表:__使用外部的js和css文件引用的方式，因为这要比直接在页面中性能更好一点；独立的一个js比用多个js文件组成的页面载入要快38%。把多个脚本合并为一个脚本，把多个样式表合并为一个样式表。  
__(4)图片使用Base64编码减少页面请求数：__  
采用Base64的编码方式将图片直接嵌入到网页中，而不是从为外部载入。  
`<img src="data:image/gif;base64,/9j/4A....">`  
3. __浏览器缓存和压缩优化技术__:  
__*HTTP缓存机制*__  

__高并发下只能通过提升服务器负载解决？__不是的，优化的点很多。  
__缓存只能做浏览器缓存吗？__:不是的，启用浏览器缓存。  

__缓存分类（两类缓存：本地缓存，协商缓存）:__  
HTTP缓存模型中，如果请求成功会有三种情况  
__200 from cache__:直接从本地缓存中获取响应，最快速，最省流量，因为根本没有向服务器发送请求。  
__304 Not Modified__:协商缓存，浏览器在本地没有命中的情况下，请求头中发送一定的校验数据到服务端，如果服务端数据没有改变，浏览器从本地缓存响应，返回304。快速，发送的数据很少，只返回一些基本的响应头信息，数据量很小，不发送实际响应体。  
__200 OK__:以上两种缓存全都失败，服务器返回完整响应。没有用到缓存，相对最慢。 
 
__本地缓存：__  
浏览器认为本地缓存可以使用，不回去请求服务端。  
相关header:  
`Pragma`:HTTP1.0时代的遗留产物，该字段设置为no-cache时，会告知浏览器禁用本地缓存，即每次都向服务器发送请求。  
`Expires`:HTTP1.0时代用来启用本地缓存的字段，expires值对应一个形如Thu, 31 Dec 2034 23:55:55 GMT 的格林威治时间，告诉浏览器缓存实现的时刻，如果还没到该时刻 ，标明缓存有效，无需发送请求。（缺陷：浏览器与服务器的时间无法保持一致，如果时间差距大，就会影响缓存结果。）  
`Cache-Control`:HTTP1.1针对Expires时间不一致的解决方案，运用Cache-Control告知浏览器缓存过期的时间间隔而不是时刻，即使具体时间不一致，也不影响缓存的管理。  

    no-store:禁止浏览器缓存响应。
    no-cache:不允许直接使用本地缓存，先发起请求和服务器协商。  
    max-age=delta-seconds:告知浏览器该响应本地缓存有效的最长期限，以秒为单位。  
优先级：  
`Pragma` > `Cache-Control` > `Expires`  
__协商缓存:__  
当浏览器没有命中本地缓存，如本地缓存过期或者响应中声明不允许直接使用本地缓存，那么浏览器肯定会发起服务端请求；  
服务端会验证数据是否修改，如果没有，通知浏览器使用本地缓存。  
相关header:  
`Last-Modified`:通知浏览器资源的最后修改时间。  
`If-Modified-Since`:得到资源的最后修改时间后，会将这个信息通过If-Modified-Since提交到服务器做检查，如果没有修改，返回状态码304。  

`ETag`:HTTP1.1推出，文件的指纹标识符，如果文件修改，指纹会改变。  
`If-None-Match`:本地缓存失效，会携带此值去请求服务器，服务端判断该资源是否改变，如果没有改变，直接使用本地缓存，返回304。  
***
__*缓存策略的选择*__:  
(1)适合本地缓存的内容:  
  不变的图像，如logo,图标。  
  js,css静态文件。  
  可下载的内容，媒体文件。  

(2)建议使用协商缓存  
  js、css文件的加载可以加入文件的签名来拒绝缓存。  
  index.css?签名  
  index.签名.js

(3)不建议缓存的内容  
  用户隐私敏感数据  
  经常改变的api接口数据。  
***
__*Nginx配置缓存策略：*__  
(1)本地缓存配置  
`expires`指令：通知浏览器过期时长。
expires time;  
为负值时表示Cache-Control:no-cache;  
当为正或者0时，就表示Cache-Control:max-age=指定的时间。  
![nginx配置expires](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/nginx_set1.png)   
当为max时，会把Expires设置为"XXX GMT",Cache-Control设置到10年。  
(2)协商缓存配置  
Etag指令：指定签名。  
etag on| off;默认on  
***
__*前端代码和资源的压缩*__:  
优势：  
让资源文件更小，加快文件在网路中的传输，让网页更快的展现，降低带宽和流量开销。  

压缩方式：  
JS、CSS、图片、HTML代码的压缩。  
Gzip压缩。  

JavaScript代码的压缩：  
JavaScript压缩的原理一般是去掉多余的空格和回车、替换长变量名、简化一些代码写法等。  
常用的压缩工具：UglifyJS、YUI Compressor、Closure、Compiler。  

CSS代码压缩：  
原理跟JavaScript	压缩原理类似，同样是去除空白符、注释并且优化一些CSS语义规则等。
常用压缩工具：YUI Compressor、CSS Compressor。    
CSS Compressor:压缩时可以选择模式。  

HTML代码压缩：  
不建议使用代码压缩，有时会破环代码结构，可以使用Gzip压缩，当然也可以使用htmlcompressor工具，不过转换后一定要检查代码结构。  

图片压缩:  
除了代码的压缩外，有时对图片的压缩也是很有必要的，一般情况下图片在Web系统的比重都比较大。  
压缩工具：tinypng、JpegMini、ImageOptim  

Gzip压缩：  
配置Nginx服务  
`gzip on|off`; #是否开启gzip  
`gzip_buffers 32 4k| 16 8k` #缓冲(在内存中缓冲几块？每块多大)  
`gzip_comp_level [1-9]`  #推荐6 压缩级别（级别越高，压得越小，越浪费CPU计算资源）  
`gzip_disable` #正则匹配UA 什么样的Uri不进行gzip  
`gzip_min_length 200` #开始压缩的最小长度  
`gzip_http_version 1.0|1.1` #开始压缩的http协议版本  
`gzip_proxied` #设置请求者代理服务器，该如何缓存内容  
`gzip_types text/plain application/xml` #对哪些类型的文件用压缩，如txt,html css  
`gzip_vary on|off` # 是否传输gzip压缩标志  

其他工具  
自动化构建工具Grunt  

 