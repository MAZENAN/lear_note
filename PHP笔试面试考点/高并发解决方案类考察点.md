- [1.高并发架构相关概念](#gn)
- [2.高并发解决方案案例](#al)
- [3.高并发方案详细说明](#sm)
# <a id="gn">高并发架构相关概念</a>  
1. __什么是高并发：__  
在互联网时代，所讲的并发、高并发，通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。通常如果一个系统的日PV在千万以上，有可能是一个高并发的系统，有的公司完全不走技术路线，全靠机器堆，这不在我们的讨论范围内。  
2.  __高并发的问题我们具体该关心什么？__  
__QPS__: 每秒钟请求或者查询的数量，在互联网领域，指的是每秒响应请求数（指的是HTTP请求）;  
__吞吐率__: 单位时间内服务器处理的请求数量，通常使用“reqs/s”来表示。我们关心的是最大吞吐率（通常由QPS与并发数决定）  
__响应时间__: 从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms,这个100ms就是系统的响应时间。  
__PV__: 综合浏览量(Page View),即页面浏览量或者点击量，一个访客在24小时内访问的页面数量。同一个人浏览你的网站的同一页面，只记作一次PV。 多次刷新同一页面只算一次。根据日均pv可以计算出峰值qps.   
__UV__: 独立访客（Unique Visitor）,即一定时间范围内相同访客多次访问网站，只计算为1个独立访客。  
__带宽__:计算带宽大小需要关注两个指标，峰值流量和页面的平均大小
    >     日网站带宽 = PV/统计时间（换算到秒）*平均页面大小（单位KB）*8
    >     峰值一般是平均值的倍数，根据实际情况来定  

    >     注意：QPS不等于并发连接数；QPS是每秒HTTP请求的数量，并发连接数是系统同时处理请求数量。 

    >     峰值每秒请求数（QPS）= （总PV数*80%）*（6小时秒数*20%）
    >     80%的访问量集中在20%的访问时间  
2.  __压力测试:__  
__常用性能测试工具__ ：ab、wrk、http_load、Web Bench、Siege、Apache JMeter  
__ab__ :全称是apache benchmark,是apache官方推出的工具创建多个并发访问线程，模拟多个访问者同时对某一个URL地址进行访问。它的测试目标基于URL，因此它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其他Web服务器的压力。  
__ab的使用__ :模拟并发请求100次，总共请求5000次。  
    >     ab -c 100 -n 5000 待测试的网站

__ab使用注意事项__ : 测试机器与被测试机器分开；不要对线上服务做压力测试；观察测试工具ab所在的机器，以及被测试的前下·端机的CPU，内存，网络等都不超过最高限度的75%。  
__QPS达到极限__：  
随着QPS的增长，每个阶段的需要根据实际情况来进行优化，优化的方案也与硬件条件、网络带宽息息相关。  
__QPS达到50__：  
可以称之为小型网站，一般的服务器就可以应付。  
__QPS达到100__：  
假设关系型数据库每次请求在0.01秒完成。假设单个页面只有一个SQL查询，那么100QPS意味着1秒钟完成100次请求，但是此时我们并不能保证数据库查询能完成100次。  
方案：数据库缓存层、数据库的负载均衡。  
__QPS达到800__：  
假设我们使用百兆带宽，意味着网站出口的实际带宽是8M左右，假设每个页面只有10K，在这个并发条件下，百兆带宽已经吃完。  
方案：CDN加速、负载均衡。   
__QPS达到1000__：  
假设使用Memcache缓存数据库查询数据，每个页面对Memcache的请求远大于直接对DB的请求；Memcache的悲观并发数在2w左右，但有可能在之前内网带宽已经吃光，表现出不稳定。  
方案：静态HTML缓存。  
__QPS达到2000__：  
这个级别下，文件系统访问锁都成了灾难。  
方案：做业务分离，分布式存储。  
# <a id="al">高并发解决方案案例</a>   
1. __流量优化__  
防盗链处理  
2. __前端优化__  
减少http请求（例如合并js、css文件）  
添加异步请求（不要一次请拿到数据） 
启用浏览器缓存和文件压缩  
CDN加速（就近访问，解决带宽不够用问题）  
建立独立的图片服务器(吃io,针对性优化（磁盘优化）)  
3. __服务端优化__  
页面静态化（直接缓存成html页面）  
（穿透了静态化、实时性要求比较高）并发处理(多线程进程异步处理、队列处理)  
4. __数据库优化__  
数据库缓存  
分库分表、分区操作  
读写分离  
负载均衡  
5. __Web服务器优化__  
负载均衡  
# <a id="sm">高并发方案详细说明</a>  
1. Web资源防盗链  
2. 减少HTTP请求次数  
__为什么减少HTTP请求__：  
__(1)性能黄金法则：__只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下80%-90%的时间花在HTML文档所引用的所有组件（图片，script,css,flash等等） 进行的HTTP请求上。  
__(2)如何改善:__改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量。  
__(3)HTTP连接产生的开销：__域名解析--TCP连接--发送请求--等待--下载资源--解析时间。  
__(4)疑问？__DNS缓存；Keep-Alive。  
__(5)打破谣言:__查找DNS缓存也需要时间，多个缓存就要查找多次有可能缓存被清除。HTTP1.1协议规定请求只能串行发送，也就是一百个请求必须逐个发送，前面一个请求完成才能开始下一个请求。  
__减少HTTP请求的方式__  
__(1)图片地图:__图片地图允许你在一个图片上关联多个URL。目标URL的选择取决于用户单击了图片上的哪个位置。将n个图片合为一张图片，然后以位置信息定位超链接把HTTP请求减少为一个，可以保证设计的完整性和功能的齐全性。  
使用`<map><area></area></map>`标签  
![语法](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/img_map.png)  
__(2)CSS Sprites:__中文翻译为CSS精灵，通过使用合并图片，通过指定css的background-image和background-position来显示元素。  
__background-position属性：__  
background-position:x y;x和y可以写负值也可以写正值,我们可以想象图片的左上方为(0,0),以(0,0)坐标向右是为负数的x轴,以(0,0)坐标向下为负数的y轴。  
![坐标](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/zuobiao.png)  
使用案例：  
![精灵使用1](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/jl1.png)   
![精灵使用2](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/jl2.png)   
![精灵使用3](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/jl3.png)   


__性能影响：__图片地图与CSS精灵的响应时间基本相同，但比使用各自独立图片的方式要快50%以上。  
__(3)合并脚本和样式表:__使用外部的js和css文件引用的方式，因为这要比直接在页面中性能更好一点；独立的一个js比用多个js文件组成的页面载入要快38%。把多个脚本合并为一个脚本，把多个样式表合并为一个样式表。  
__(4)图片使用Base64编码减少页面请求数：__  
采用Base64的编码方式将图片直接嵌入到网页中，而不是从为外部载入。  
`<img src="data:image/gif;base64,/9j/4A....">`  
3. __浏览器缓存和压缩优化技术__:  
__*HTTP缓存机制*__  

__高并发下只能通过提升服务器负载解决？__不是的，优化的点很多。  
__缓存只能做浏览器缓存吗？__:不是的，启用浏览器缓存。  

__缓存分类（两类缓存：本地缓存，协商缓存）:__  
HTTP缓存模型中，如果请求成功会有三种情况  
__200 from cache__:直接从本地缓存中获取响应，最快速，最省流量，因为根本没有向服务器发送请求。  
__304 Not Modified__:协商缓存，浏览器在本地没有命中的情况下，请求头中发送一定的校验数据到服务端，如果服务端数据没有改变，浏览器从本地缓存响应，返回304。快速，发送的数据很少，只返回一些基本的响应头信息，数据量很小，不发送实际响应体。  
__200 OK__:以上两种缓存全都失败，服务器返回完整响应。没有用到缓存，相对最慢。 
 
__本地缓存：__  
浏览器认为本地缓存可以使用，不回去请求服务端。  
相关header:  
`Pragma`:HTTP1.0时代的遗留产物，该字段设置为no-cache时，会告知浏览器禁用本地缓存，即每次都向服务器发送请求。  
`Expires`:HTTP1.0时代用来启用本地缓存的字段，expires值对应一个形如Thu, 31 Dec 2034 23:55:55 GMT 的格林威治时间，告诉浏览器缓存实现的时刻，如果还没到该时刻 ，标明缓存有效，无需发送请求。（缺陷：浏览器与服务器的时间无法保持一致，如果时间差距大，就会影响缓存结果。）  
`Cache-Control`:HTTP1.1针对Expires时间不一致的解决方案，运用Cache-Control告知浏览器缓存过期的时间间隔而不是时刻，即使具体时间不一致，也不影响缓存的管理。  

    no-store:禁止浏览器缓存响应。
    no-cache:不允许直接使用本地缓存，先发起请求和服务器协商。  
    max-age=delta-seconds:告知浏览器该响应本地缓存有效的最长期限，以秒为单位。  
优先级：  
`Pragma` > `Cache-Control` > `Expires`  
__协商缓存:__  
当浏览器没有命中本地缓存，如本地缓存过期或者响应中声明不允许直接使用本地缓存，那么浏览器肯定会发起服务端请求；  
服务端会验证数据是否修改，如果没有，通知浏览器使用本地缓存。  
相关header:  
`Last-Modified`:通知浏览器资源的最后修改时间。  
`If-Modified-Since`:得到资源的最后修改时间后，会将这个信息通过If-Modified-Since提交到服务器做检查，如果没有修改，返回状态码304。  

`ETag`:HTTP1.1推出，文件的指纹标识符，如果文件修改，指纹会改变。  
`If-None-Match`:本地缓存失效，会携带此值去请求服务器，服务端判断该资源是否改变，如果没有改变，直接使用本地缓存，返回304。  
***
__*缓存策略的选择*__:  
(1)适合本地缓存的内容:  
  不变的图像，如logo,图标。  
  js,css静态文件。  
  可下载的内容，媒体文件。  

(2)建议使用协商缓存  
  js、css文件的加载可以加入文件的签名来拒绝缓存。  
  index.css?签名  
  index.签名.js

(3)不建议缓存的内容  
  用户隐私敏感数据  
  经常改变的api接口数据。  
***
__*Nginx配置缓存策略：*__  
(1)本地缓存配置  
`expires`指令：通知浏览器过期时长。
expires time;  
为负值时表示Cache-Control:no-cache;  
当为正或者0时，就表示Cache-Control:max-age=指定的时间。  
![nginx配置expires](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/nginx_set1.png)   
当为max时，会把Expires设置为"XXX GMT",Cache-Control设置到10年。  
(2)协商缓存配置  
Etag指令：指定签名。  
etag on| off;默认on  
***
__*前端代码和资源的压缩*__:  
优势：  
让资源文件更小，加快文件在网路中的传输，让网页更快的展现，降低带宽和流量开销。  

压缩方式：  
JS、CSS、图片、HTML代码的压缩。  
Gzip压缩。  

JavaScript代码的压缩：  
JavaScript压缩的原理一般是去掉多余的空格和回车、替换长变量名、简化一些代码写法等。  
常用的压缩工具：UglifyJS、YUI Compressor、Closure、Compiler。  

CSS代码压缩：  
原理跟JavaScript	压缩原理类似，同样是去除空白符、注释并且优化一些CSS语义规则等。
常用压缩工具：YUI Compressor、CSS Compressor。    
CSS Compressor:压缩时可以选择模式。  

HTML代码压缩：  
不建议使用代码压缩，有时会破环代码结构，可以使用Gzip压缩，当然也可以使用htmlcompressor工具，不过转换后一定要检查代码结构。  

图片压缩:  
除了代码的压缩外，有时对图片的压缩也是很有必要的，一般情况下图片在Web系统的比重都比较大。  
压缩工具：tinypng、JpegMini、ImageOptim  

Gzip压缩：  
配置Nginx服务  
`gzip on|off`; #是否开启gzip  
`gzip_buffers 32 4k| 16 8k` #缓冲(在内存中缓冲几块？每块多大)  
`gzip_comp_level [1-9]`  #推荐6 压缩级别（级别越高，压得越小，越浪费CPU计算资源）  
`gzip_disable` #正则匹配UA 什么样的Uri不进行gzip  
`gzip_min_length 200` #开始压缩的最小长度  
`gzip_http_version 1.0|1.1` #开始压缩的http协议版本  
`gzip_proxied` #设置请求者代理服务器，该如何缓存内容  
`gzip_types text/plain application/xml` #对哪些类型的文件用压缩，如txt,html css  
`gzip_vary on|off` # 是否传输gzip压缩标志  

其他工具  
自动化构建工具Grunt

4. __CDN__ 
 
*__什么是CDN__*?  
CDN的全称是Content Delivery Network ,即内容分发网络。  
尽可能避开互联网上有可能影响传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。  在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层只能虚拟网络。  
CND系统能够实时的根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向距离用户最近的服务节点上。
  
*__使用CDN的优势__*：  
本地Cache加速，提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度。  
跨运营商的网络加速，保证不同网络的用户都得到了良好的访问质量。  
远程访问用户根据DNS负载均衡技术职能自动选择Cache服务器。  
自动生成服务器的远程Mirror(镜像)cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。  
广泛分布的CND节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵。  

__*CDN的工作原理*__:  
传统访问：用户在浏览器输入域名发起请求-->解析域名获取服务器IP地址-->根据IP地址找到对应的服务器-->服务器响应并返回数据。  

使用CDN访问：  
用户发起请求-->智能DNS的解析(根据IP判断地理位置、接入网类型、选择路由最短和负载最轻的服务器)-->取得缓存服务器IP-->把内容返回给用户(如果缓存中有)-->向源站发起请求-->将结果返回用户-->将结果存入缓存服务器。  
![CDN原理](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/cdn.png)  

__*CDN的适用场景：*__  
站点或者应用中大量静态资源的加速分发。例如：CSS,JS,图片和HTML  
大文件下载  
直播网站  

__*CDN的实现*__:  
BAT等都有提供CDN服务。  
可用LVS做4层负载均衡。  
可用Nginx、Varnish、Squid、Apache TrafficServer做7层负载均衡和cache。  
使用squid方向代理，或者Nginx等的方向代理。  

5. __独立图片服务器的部署__:  

__*独立的必要性*__ :  
分担Web服务器的I/O负载-将耗资源的图片服务分离出来，提高服务器的性能和稳定性。  
能够专门对图片服务器进行优化-为图片服务设置有针对性的缓存方案，减少带宽成本，提高访问速度。  
提高网站的可扩展性-通过增加图片服务器，提高图片吞吐能力。  

__*采用独立域名*__:  
原因：  
同一域名下浏览器的并发连接数有限制，突破浏览器连接数的限制。  
由于cookie的原因，对缓存不利，大部分Web cache都只缓存不带cookie的请求，导致每次图片请求都不能命中cache。 
 
__*独立后的问题 *__:  
如何进行图片上传和图片同步：  
NFS共享方式；  
利用FTP同步；  
利用接口。  

6. __动态语言静态化__: 
 
__*什么是动态语言静态化*__：  
将现有PHP等动态语言的逻辑代码生成为静态HTML文件，用户访问动态脚本重定向到静态HTML文件的过程。  
对实时性要求不高的页面。  
 
__*原因：*__  
动态脚本通常会做逻辑计算和数据查询，访问量越大，服务器压力越大  
访问量大时可能会造成CPU负载过高，数据库服务器压力过大  
静态化可以减低逻辑处理压力，降低数据库服务器查询压力。  

__*静态化实现的方式*__:  
使用模板引擎。  
例如smarty。  

__*利用ob系列函数*__  
`ob_start();`  
输出到页面的HTMl代码...  
...  
`ob_get_contents();`  
`ob_end_flush();`  
`fopen();`写入  

可以判断文件的inode修改时间,判断是否过期。  
使用filectime函数。  
![语言静态化](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/yyjth.png)  

7. __动态语言的并发处理__:  
流量穿透了静态化等优化走到动态脚本，就需要去做一些除了静态化的内容。  
 
一、什么是进程、线程、协程？  
__(1)进程：__
  
是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。  
进程是一个"执行中的程序"  

__进程的三态模型：__  
多道程序系统中，进程在处理器上交替运行，状态不断地发生变化运行。 
 
➀ __运行__：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。  
➁ __就绪__：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。   
➂ __阻塞__：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O 而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。  

__进程的五态模型：__  
对于一个实际的系统，进程的状态及其转换更为复杂。（新建态、活跃就绪／静止就绪、运行、活跃阻塞／静止阻塞、终止态）  
  
➀ __新建态__：对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息。  
➁ __终止态__：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息。   
➂ __活跃就绪__：是指进程在主存并且可被调度的状态。  
➃  __静止就绪（挂起就绪）__：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存引防换为活跃就绪。  
➄  __活跃阻塞__：是指进程已在主存，一旦等待的．件产生便进入活跃就绪状态。   
➅  __静止阻塞__：进程对换到辅存时的阻塞状态，一旦等待的事件产生便进入静止就绪状态。

__(2)线程：__  

由于用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销方面或是响应用户请求的效率方面来看。因此操作系统中线程的概念便被引进了。  
有时被称为轻量级进程（ Lightweight Process , LwP ) , 是程序执行流的最小单元。    
线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源但它可与同属一个进程的其它线程共享进程所拥有的全部资源。  
一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。    
线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。  
在单个程序中同时运行多个线程完成不同的工作，称为多线程。  
每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。


__线程的状态：__ 就绪、阻塞、运行。  
➀ __就绪状态__：线程具备运行的所有条件，逻辑上可以运行，在等待处理机。  
➁ __运行状态__：线程占有处理机正在运行。  
➂ __阻塞状态__：线程在等待一个事件（如某个信号， ) ，逻辑上不可执行。  

__(3)协程：__    

是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候．恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。  

__(4)进程与线程的区别：__   
➀ 线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间。  
➁ 进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源。    
➂ 线程是处理器调度的基本单位，但进程不是。  
➃ 二者均可并发执行。  
➄ 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。  

__(5)进程与协程的区别：__  
➀ 一个线程可以多个协程，一个进程也可以单独拥有多个协程。  
➁ 线程进程都是同步机制，而协程则是异步。  
➂ 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 

二、 什么是多进程、多线程：   
➀ 多进程：同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这就是多进程。边看慕课网视频，边使用 WebIDE。多开一个进程，多分配一份资源，进程间通讯不方便。  
➁ 多线程：线程就是把一个进程分为很多片，每一片都可以是一个独立的流程与多进程的区别是只会使用一个进程的资源，线程间可以直接通信。  

__(1)多个概念的区别：__  
➀ 单进程单线程：一个人在一个桌子上吃菜。  
➁ 单进程多线程：多个人在同一个桌子上一起吃菜。  
➂ 多进程单线程：多个人每个人在自己的桌子上吃。   

三、 同步阻塞：  
__(1)多进程：__最早的服务器端程序都是通过多进程、多线程来解决并发IO的问题。  
一个请求创建一个进程，然后子进程进入循环同步堵塞地与客户端连接进行交互，收发处理数据。  
__(2)多线程：__用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。

__(3)实现步骤：__  
创建一个 socket。  
进入 while 循环，阻塞在进程 accept 操作上，等待客户端连接进入主进程在多进程模型下通过 fork 创建子进程。  
多线程模型下可以创建子线程。  
子进程/子线程创建成功后进入 while循环，阻塞在recv调用上，等待客户端向服务器发送数据。  
收到数据后服务器程序进行处理然后使用 send 向客户端发送响应。  
当客户端连接关闭时，子进程/线程退出并销毁所有资源。主进程/线程会回收掉此子进程/线程。  

__(4)缺点：__  
➀ 这种模型严重依赖进程的数量解决并发问题。  
➁ 启动大里进程会带来额外的进程调度消耗。  
代码模拟实现：  

    <?PHP
    $sockserv = stream_socket_server('[tcp://0.0.0.0:8000](tcp://0.0.0.0:8000)', $errno, $errstr);
    for ($i = 0; $i < 5; $i++) {
    if (pcntl_fork() == 0) {
        while (true) {
            $conn = stream_socket_accept($sockserv);
            if ($conn == false) {
                continue;
            }
            $request = fread($conn, 9000);
            $response = 'hello';
            fwrite($conn, $response);
            fclose();
        }
        exit;
     }
    }

四、 异步非阻塞：  

现在各种高并发异步 I/O 的服务器程序都是基于 epoll实现的。  
IO 复用异步非阻塞程序使用经典的 Reactor 模型， Reactor 顾名思义就是反应堆的意思，它本身不处理任间数据收发。只是可以监视一个 socket 句柄的事件变化。  
  
![Reactor模型](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/reactor.png)  
Reactor 有 4 个核心的操作：  
➀ add 添加 socket 监听到 reactor	  
➁ set 修改事件监听，可以设置监听的类型，如可读、可写  
➂ del 从 reactor 中移除，不再监听事件  
➃ cabllack ，事件发生后对应的处理逻辑，一般在 add/set 时制定  

Nginx : 多线程Reactor  
Swoole ：多线程Reactor + 多进程Worker

代码举例:
  
     <?PHP
    $reactor = new Reactor();
    $sockserv = stream_socket_server('[tcp://0.0.0.0:8000');](tcp://0.0.0.0:8000');)
    $reactor->add($sockserv, EV_READ, function () use ($sockserv, $reactor) {
    $sockcli = stream_socket_accept($sockserv);
    $reactor->add($sockcli, EV_READ, function () use ($sockcli, $reactor) {
        $request = fread($sockcli, 10000);
        $reactor->add($sockcli, EV_WRITE, function () use ($sockcli, $request) {
            fwrite($sockcli, 'test');
            $reactor->del($sockcli);
            fclose($sockcli);
        });
     });
    })  

五、 PHP并发编程实践：  

__1. PHP的Swoole扩展__:  

PHP 的异步、并行、高性能网络通信引攀，使用纯 C 语言编写，提供了PHP 语言的异步多线程服务器，异步 TCP / UDP 网络客户端，异步 MySQL ，异步 Redis ，数据库连接池， AsyncTask ．消息队列，毫秒定时器，异步文件读写，异步 DNS 查询。  
除了异步 I/O 的支持之外， Swoole 为 PHP 多进程的模式设计了多个并发数据结构和 IPC 通信机制，可以大大简化多进程并发编程的工作。  
Swoole2.0 支持了类似 GO 语言的协程，可以使用完全同步的代码实现异步程序。
  
Swoole 的异步 MysqL 实现：  

    <?php
    $db = new Swoole\MySQL;
    $server = array('host' => '', 'user' => '', 'password' => '', 'database' => '');
    $db->connect($server, function($db, $result){
    $db->query('show tables', function(Swoole\MySQL, $db, $result){
        do some thing 
     });
    });  

__2. 消息队列__:  

__场景说明：__  

  __*场景1：用户注册后，需要发注册邮件和注册短信。*__  

➀ 串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。  
➁ 并行方式：将注册信息写入数据库成功后，发送注册邮件的同时．发送注册短信。  
➂ 消息队列方式：将注册信息写入数据库成功后．将成功信息写入队列，此时直接返回成功给用户，写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信。  

__*场景2：应用解耦。*__  

用户下单后，订单系统要通知库存系统。  
假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。  
订单系统与库存系统耦合。  

引用队列：  
用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。  
订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。  

__*场景3：流量削峰。*__  
  
秒杀活动，流量瞬时激增，服务器压力大。  
用户发起请求，服务器接收后，先写入消息队列。假如消息队列长度超过最大值，则直接报错或提示用户。  
后续程序读取消息队列再做处理。  
控制请求量。  
缓解高流量。  

__*场景4:日志处理.*__

解决大量日志的传输。  
日志采集程序将程序写入消息队列，然后通过日志处理程序的订阅消费日志。  

__*场景5:消息通讯.*__  

聊天室。  
多个客户端订阅同一个主题，进行消息发布和接收。  

__*常见消息队列产品*__   
kafka、redis、activeMQ、zeroMQ、RabbitMQ等。  

__3. 接口的并发请求__:  
`curl_multi_int()`  

8、数据库缓存。  

__(1) 什么是数据库缓存？__  
MySQL等一些常见的关系型数据库的数据都存储在磁盘当中，在高并发场景下，业务应用对 MySQL产生的增、删、改、查的操作造成巨大的 I/O 开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生。  

极大地解决数据库服务器的压力。  
提高应用数据逇响应速度。  

常见的缓存形式：内存缓存、文件缓存。 着重介绍内存缓存。  

__(2) 为什么要使用缓存？__   

缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程度地降低对数据库服务器的访问压力。  
   
用户请求--＞数据查询--＞连接数据库服务器并查询数据--＞将数据缓存起来（HTML 、内存、 JSON 、序列化数据）--＞显示给客户端。  

用户再次请求或者新用户访问--＞数据查询--＞直接从缓存中获取数据--＞显示给客户端。

__(3)缓存需要考虑的内容：__    
  
➀ 缓存方式的选择  
➁ 缓存场景的选择  
➂ 缓存数据的实时性  
➃ 缓存数据的稳定性  

__(4)使用Mysql查询缓存(了解)：__   

启用Mysql查询缓存。  
极大地降低CPU使用率。

➀ `query_cache_type` :   
查询缓存类型，有0、1、2 三个取值 0不使用，1表示始终使用，2表示按需使用  
 
query_cache_type = 1时，也可以关闭查询缓存：  
  
    select SQL_NO_CACHE * from tbl_name where condition；
query_cache_type为2时，可按需使用查询缓存：  

    select SQL_CACHE * from tbl_name where condition； 

➁ `query_cache_size`   
默认为0，表示查询缓存预留的内存为0，则无法使用查询缓存 
 
    SET GLOBAL query_cache_size = 11312312  

➂ 说明：  
查询缓存可以看做是SQL文本和查询结果的映射。  
第二次查询的SQL和第一次查询的SQL完全相同，则会使用缓存。
`show status like “Qcache_hits”;`  查看命中次数。  
表的结构或数据发生变化时，查询缓存中的数据不再有效。
  
➃ 清理缓存

    flush query cache；//清理查询缓存内存碎片
	reset query cache；//从查询缓存中移出所有查询
    flush tables;//关闭所有打开的表。同事清空上查询缓存中的内容

__(5)使用Memcache缓存 ：__
 
对于大型站点，如果没有中间缓存层，当流量打入数据库层时，即便有之前的几层为我们档住一部分流量，但是在大并发的情况下，还是会有大量请求涌入数据库层，这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。  
memcache 是一套分布式的高速缓存系统，由 Livejournal 的 Brad Fitzpatrick 开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。

➀ 工作原理：  
Memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存，然后从内存中读取，从而大大提高读取速度
 
➁ 工作流程。  
先检查客户端的请求数据是否在 memcached 中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在 m emcached 中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到 memcached 中。 
 
➂ 方法  
获取 get(key)；  
设置 set(key, val,expire)  
删除 delete(key)  

➃ 通用缓存机制   
用查询的方法名+参数作为查询时的key value 对应的key值。  

__(6)使用Redis缓存：__   
 
➀ 什么是redis  
redis是nosql(也是个巨大的map) 单线程，但是可处理1秒10w的并发（数据都在内存中）
使用java对redis进行操作类似jdbc接口标准对mysql，有各类实现他的实现类，我们常用的是druid  

其中对redis，我们通常用Jedis(也为我们提供了连接池JedisPool)
在redis中,key就是byte  

redis的数据结构(value):String,list,set,orderset,hash。
   
➁ redis的使用   

先安装好redis，然后运行，在pom文件中引入依赖，在要使用redis缓存的类的mapper.xml文件配置redis的全限定名。引入redis的redis.properties文件（如果要更改配置就可以使用）  

应用场景:

`String` :
  存储json类型对象
  计数器
  优酷视频点赞等  

`list`(双向链表)  
  可以使用redis的list模拟队列,堆,栈  
  朋友圈点赞(一条朋友圈内容语句,若干点赞语句)  
  规定:朋友圈内容的格式:  
  内容: user:x:post:x content来存储;  
  点赞: post:x:good list来存储;(把相应头像取出来显示)    

`hash(hashmap) `   
保存对象  
分组  

③、string与hash的数据差别  
在网路传输时候，必须要进行进行序列化，才可以进行网路传输，那么在使用string类型的类型的时候需要进行相关序列化，hash也是要进行相关的系列化，所以会存在很多序列化，在存储的时候hash是可以存储的更加丰富，但是在反序列化的时候，string的反序列化相对较低，而hash的序列化和返序列化是相对hash类更加复杂，所以看业务场景，如果是数据经常修改的那种，为了性能可以使用string，如果是数据不是经常改的那种就可以使用hash，由于hash，存储数据时比较丰富，可以存储多种数据类型

④、redis的持久化方式：  
能，将内存中的数据异步写入硬盘中，两种方式：RDB（默认）和AOF  
RDB持久化原理：通过bgsave命令触发，然后父进程执行fork操作创建子进程，子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换（定时一次性将所有数据进行快照生成一份副本存储在硬盘中）  

优点：是一个紧凑压缩的二进制文件，Redis加载RDB恢复数据远远快于AOF的方式。  

缺点：由于每次生成RDB开销较大，非实时持久化，  

AOF持久化原理：开启后，Redis每执行一个修改数据的命令，都会把这个命令添加到AOF文件中。  

优点：实时持久化。  

缺点：所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积，加载慢  

⑤、redis单线程为什么这么快  
redis是单线程的，但是为什么还是这么快呢，  
　　 原因1： 单线程，避免线程之间的竞争  
　　 原因2 ：是内存中的，使用内存的，可以减少磁盘的io  
　　 原因3：多路复用模型，用了缓冲区的概念，selector模型来进行的  

⑥、redis主挂了怎么操作  
redis提供了哨兵模式，当主挂了，可以选举其他的进行代替，哨兵模式的实现原理，就是三个定时任务监控，  

每隔10s，每个S节点（哨兵节点）会向主节点和从节点发送info命令获取最新的拓扑结构
每隔2s，每个S节点会向某频道上发送该S节点对于主节点的判断以及当前Sl节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他S节点以及它们对主节点的判断（做客观下线依据）  
每隔1s，每个S节点会向主节点、从节点、其余S节点发送一条ping命令做一次心跳检测(心跳检测机制)，来确认这些节点当前是否可达  
　　当三次心跳检测之后，就会进行投票，当超过半数以上的时候就会将该节点当做主  

⑦、redis集群  
redis集群在3.0以后提供了ruby脚本进行搭建，引入了糙的概念，  
　　Redis集群内节点通过ping/pong消息实现节点通信，消息不但可以传播节点槽信息，还可以传播其他状态如：主从状态、节点故障等。因此故障发现也是通过消息传播机制实现的，主要环节包括：主观下线（pfail）和客观下线（fail）  
　　主客观下线：  
　　主观下线：集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。如果通信一直失败，则发送节点会把接收节点标记为主观下线（pfail）状态。  
　　客观下线：超过半数，对该主节点做客观下线  
　　主节点选举出某一主节点作为领导者，来进行故障转移。  
　　故障转移（选举从节点作为新主节点）  

⑧、内存淘汰策略  
Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。  
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。  
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。  
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。  
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。  
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。  

⑨、缓存击穿的解决方案：  
原因：就是别人请求数据的时候，很多数据在缓存中无法查询到，直接进入数据查询，  

解决方法，对相关数据进行查询的数据只查询缓存，如果是一些特殊的可以进行数据库查询，也可以采用布隆过滤器进行查询  

⑩、缓存雪崩的解决方案：  
缓存雪崩的原因：一次性加入缓存的数据过多，导致内存过高，从而影响内存的使用导致服务宕机  

解决方法：  

redis集群，通过集群方式将数据放置  
后端服务降级和限流：当一个接口请求次数过多，那么就会添加过多数据，可以对服务进行限流，限制访问的数量，这样就可以减少问题的出现。    
  
⑪、与Memcache的区别  
性能相差不大  
Redis2.0版本后增加了自己的VM特性，突破物理内存的限制，Memecache可以修改最大可用内存，采用LRU算法  
Redis依赖客户端实现分布式读写  
Memcache本身没有数据冗余机制  
Redis支持快照，AOF，依赖快照进行持久化，AOF增强了可靠性的同时，对性能有所影响  
Memcache不支持持久化，通常做缓存，提升性能  
Memcache在并发场景下，用cas保证一致性，redis事务处理比较弱，只能保证事务中的每个操作连续执行  
Redis支持多种数据类型 字符串string，列表list，散列hash，集合set，有序集合sorted set  
Redis用于数据量较小的高性能操作和运算上  
Memecache用于在动态系统中减少数据库的负载，提升性能，适合做缓存，提高性能  

__(7)缓存其他数据：__  
Session（不建议存在MySQL中，存在Redis或Memcache中）  
session_set_save_handle