- [1.基础考点](#jc)
- [2.创建高性能索引考点](#sy)
- [3.SQL语句编写考点](#bx)
- [4.SQL语句查询优化考点](#cxyh)
- [5.MySQL的高可扩展和高可用考点](#gky)
- [6.MySQL的安全性考察点](#aqx)
# <a id="jc">基础考点</a>
## 数据类型   

__*整数类型*:__  
    
    TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT  
    属性：UNSIGNED  
    长度：可是为整数类型指定宽度、例如：INT(11)、对大多数应用是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数。  

__*实数类型*__:  

    FLOAT、DOUBLE、DECIMAL  
    DECIMAL可以存储比BIGINT还大的整数；可以用于存储精确的小数FLOAT和DOUBLE类型支持使用标准的浮点数进行近似运算。    
  
__*字符串类型：*__  
    
    VARCHAR、CHAR、TEXT、BLOB  

    VARCHAR类型用于存储可变长字符串，他比定长类型更节省空间  
    VARCHAR使用1个或2个额外字节记录字符串的长度，列长度小于255字节，使用1个字节表示，否则使用2个  
    VARCHAR长度，如果存储内容超过指定长度，会被截断，有的版本设置还会报错 
 
    CHAR是定长的，根据定义的字符串长度分配足够的空间  
    CHAR会根据需要采用空格进行填充以方便比较，尾部空格取出可能会丢失 
    CHAR适合存储很短的字符串，或者所有值都接近同一个长度  
    CHAR长度，超出设定的长度，会被截断  
    
    对于经常变更的数据，CHAR比VARCHAR更好，CHAR不容易产生碎片  
    对于非常短的列，CHAR比VARCHAR在存储空间上更有效率  
    只分配真正需要的空间，更长的列会消耗更多的内存  
    尽量避免使用BLOB/TEXT类型，查询会使用临时表，导致更严重的性能开销。  

__*枚举*__：  

    有时可以使用枚举代替常用的字符串类型  
    把不重复的集合存储成一个预定义的集合  
    非常紧凑，把列表值压缩到一个或二个字节  
    内部存储的是整数  
    尽量避免使用数字作为ENMU枚举的常量，易混乱  
    排序是按照内部存储的整数进行排序  
    枚举表会使表大大减小  

__*日期和时间类型*__  
   
    尽量使用TIMESTAMP,比DATETIME空间效率高  
    用整数保存时间戳的格式通常不方便处理  
    如果要存储微秒，可以使用bigint存储  

__*列属性*__：  
    auto_increment、default、not null、zarofil  

## 常见操作  

    MySQL的连接和关闭：mysql -u -p -h -P  
    其他：\G \c \q \s \h \d  

## MySQL数据表引擎  
    
__*InnoDB表引擎：*__  

    默认事务性引擎，最重要最广泛的存储引擎，性能非常优秀  
    数据存储在共享表空间，可以通过配置分开  
    对主键查询的性能高于其他类型的存储引擎  
    内部做了很多的优化，从磁盘读取数据时自动在内存构建hash索引，插入数据时自动构建插入缓冲区  
    通过一些机制和工具支持真正的热备份  
    支持崩溃后的安全恢复  
    支持行级锁  

__*MyISAM引擎*__  
 
     5.1版本之前是默认的存储引擎  
     拥有全文索引、压缩、空间函数  
     不支持事务和行级锁，不支持崩溃后的安全恢复  
     表存储在两个文件，MYD和MYI  
     设计简单，某些场景下性能很好  

__*其他表引擎*__  
    
    Archive、Blackhole、CSV、Memory  
    优先选择InnoDB  

## MySQL锁机制  

__*基础概念*__：  

    表锁是日常开发当中常见的问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。  
    共享锁和排他锁，其实就是读锁和写锁。  

	读锁：共享的，不阻塞，多个用户可以同时读一个资源，互不干扰。  
	写锁：排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一个人进行写入，防止其他用户读取正在写入的资源。  

__*锁粒度：*__  


表锁：系统性能开销最小，会锁定整张表，MyISAM使用表锁。  

行锁： 最大程度的支持并发处理，但是也带来了最大的开销，InnoDB实现行级锁。  

## 事务处理  

MySQL提供事务处理的表引擎，InnoDB  
服务器不管理事务，由下层的引擎实现，所以同一个事务中，使用多种存储引擎不靠谱  
在非事务的表上执行事务操作MySQL不会发出提醒，也不会报错  
### 事务具有四个特征ACID:  
1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。  

2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。  
3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。  

4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。    

### 事务的隔离级别  
__(1) 事务的并发问题__  
➀  脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据  
➁ 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。  
➂  幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。  


__(2) 事务的隔离级别__  https://www.cnblogs.com/wyaokai/p/10921323.html

| 事务隔离级别               | 脏读	   |  不可重复读  |  幻读|  
|:--------                  | :-----  | :----        |     :---- |  
| 读未提交（read-uncommitted |   是     |   是        |    是|    
| 不可重复读（read-committed |   否     |   是        |    是 |    
| 可重复读（repeatable-read）|    否    |  否         |    是 |  
|串行化（serializable）      |    否    |    否        |   否|    




补充：

    1、事务隔离级别为读提交时，写数据只会锁住相应的行

    2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。

    3、事务隔离级别为串行化时，读写数据都会锁住整张表
    4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
## 存储引擎  

    为以后的使用而保存的一条或多条的MySQL语句的集合  
    存储过程就是有业务逻辑和流程的集合  
    可以在存储过程中创建表，更新数据，删除。  
    
    使用场景：  
    通过把处理封装在容易使用的单元中，简化复杂的操作  
    保证数据的一致性  
    简化对变动的管理  

## MySQL的触发器  
  
    触发器：  
    提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程  
    
    使用场景：  
    可通过数据库中的相关表实现级联更改  
    实时监控某张表中的某个字段的更改而需要做出相应的处理  
    某些业务编号的生成等  
    
    滥用会造成数据库及应用程序的维护困难  


## 数据库设计三范式  
设计数据库的时候所依据的规范  
 
(1) 第一范式：  主键、字段不能再分
    
    定义：要求有主键，数据库中不能出现重复记录，每一个字段是原子性不能再分；  
    结论：关于第一范式
    1、 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，
    2、 主键主要通常采用数值型或定长字符串表示
    3、 关于列不可再分，应根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段了； 

(2) 第二范式：非主键字段完全依赖主键  

    定义：第二范式是建立在第一范式基础之上，要求数据库中所有非主键字段完全依赖主键，不能产生部分依赖；（严格意义上说：尽量不要使用联合主键）  

    结论：一种典型的“多对多”的设计  

(3) 第三范式：

    定义：建立在第二范式基础之上，要求非主键字段不能产生传递依赖亍主键字段；  

    结论：典型的一对多
     以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键
# <a id="sy">创建高性能索引</a>  
## 索引的基础  

    索引类似于书籍的目录，要想找到一本数的某个特定主题，需要先查找书的目录，定位对应的页码。  
    存储引擎使用类似的方式进行数据查询，先去索引当中找到对应的值，然后根据匹配的索引找到对应的数据行。
  
## 索引对性能的影响  
    
    大大减少服务器需要扫描的数据量  
    帮助服务器避免排序和临时表  
    将随机I/O变顺序I/O  
    大大提高查询速度，降低写的速度，占用磁盘  

## 索引的使用场景  
    对于非常小的表，大部分情况下全表扫描效率更高   
    中到大型表，索引非常有效  
    特大型的表，建立和使用索引的代价将随之增长，可以使用分区技术来解决  

## 索引的类型  
    索引有很多类型，都是实现在存储引擎层的  
    普通索引：最基本的索引，没有任何约束限制  

    唯一索引：与普通索引类似，但是具有唯一约束性 
 
    主键索引：特殊的唯一索引，不允许有空值  

    （一个表只能有一个主键索引，可以有多个唯一索引  
    主键索引一定是唯一索引，唯一索引不是主键索引  
    主键可以与外键构成参照性约束，防止数据不一致 ）  

    组合索引：将多个列组合在一起创建索引，可以覆盖多个列  

    外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作  

    全文索引：MySQL自带的全文索引只能用于MyISAM,并且只能对英文进行全文索引  

## MySQL索引的创建原则  
    
    原则：  

     1.最适合索引的列是出现在WHERE子句中的列，或连接子句中的列（0n）而不是出现在SELECT关键字后的列  

     2.索引列的基数越大，索引的效果越好  
     
     3.对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间  

     4.跟据情况创建复合索引，复合索引可以提高查询效率  
     
     5.避免创建过多索引，索引会额外占用磁盘空间，降低写操作效率  
     
     6.主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率  

     注意：  

     1.复合索引遵循的前缀原则  
      例如：key(a,b,c) 则只有where a=1 and b=2 and c=3；where a=1 and b=2;where a=1;三种情况生效。 
     2.like查询，%不能在前，可以使用全文索引  
     3.column is null 可以使用索引  
     4.如果MySQL估计使用索引比全表扫描更慢，会放弃使用索引  
     5.如果or前的条件中的列有索引，后面的没有，索引不会被用到  
     6.列类型是字符串，查询时一定要给值加引号，否则索引失效  

# <a id="bx">SQL语句编写考点</a>  
## 关联更新  
     UPDATE A,B SET A.c1=B.c1,A.c2=B.c2 where A.id=B.id  
     
     UPDATE A INNER JOIN B ON A.id=B.id SET A.c1=B.c1,A.c2=B.c2 WHERE ...  

## 六种关联查询  
交叉连接，内连接，外连接，联合查询，全连接
# <a id="gky">MySQL的高可扩展和高可用考点</a>  
## 分区表的原理  
工作原理  

    对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件  
    创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只需要查询所需数据在的分区即可  
    分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性删除整个分区的数据也很方便  

![分区表](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/fq.png)  

适用场景  
    
     1.表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据  
     2.分区表的数据更易维护，可以对独立的分区进行独立的操作  
     3.分区表的数据可以分布在不同的机器上，从而高校的使用资源  
     4.可以使用分区表来避免某些特殊的瓶颈  
     5.可以备份和恢复独立的分区  
限制  

     1.一个表最多只能有1024个分区  
     2.5.1版本中，分区表表达式必须是整数，5.5可以使用列分区  
     3.分区字段中如果有主键和唯一索引列，那么主键列和唯一列都必须包含进来  
     4.分区表中无法使用外键索引  
     5.需要对现有表的结构进行修改  
     6.所有分区都必须使用相同的存储引擎  
     7.分区函数中可以使用的函数和表达式会有一些限制  
     8.某些存储引擎不支持分区  
     9.对于MyISAM的分区表，不能使用load index into cache  
     10.对于MyISAM表，使用分区表时需要打开更多的文件描述符  
## 分库分表的原理  
工作原理  

    通过一些HASH算法或者工具实现将一张数据表垂直或者水平进行物理切分  

适用场景  

     1.单表记录条数达到百万到千万级别时  
     2.解决表锁的问题  
     
分表方式  
 
__*水平分割*__  
![水平分表](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/spfb.png) 
  
    表很大，分割可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度  
    
    使用场景  
     1.表中的数据本身就有独立性，例如表中分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。  
     2.需要把数据存放在多个介质上  
	
    水平分表的缺点：  
     1.给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需要UNION操作  
     2.在许多数据库应用中，这种复杂性会超过它带来的优点，查询时会增加读一个索引层的磁盘次数  

__*垂直分表*__  

![垂直分表](https://github.com/MAZENAN/lear_note/blob/master/PHP%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/img/czfb.png)  

    把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中  

    使用场景  
     1.如果一个表中某些列常用，而另外一些列不常用  
     2.可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数  

    垂直分表缺点：  
    管理冗余列，查询所有数据需要JOIN操作  

分表缺点  
    
    有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差  


## MySQL的复制原理及负载均衡  
MySQL主从复制原理  
    
    在主库上把数据更改记录到二进制日志  
    从库将主库的日志复制到自己的中继日志
    从库读取中继日志中的事件，将其重放到从库数据中  

MySQL主从复制解决的问题  

    数据分布：随意停止或开始复制，并在不同地理位置分布数据备份  
    负载均衡:降低单个服务器的压力  
    高可用和故障切换：帮助应用程序避免单点失败  
    升级测试：可以使用更高版本的MySQL作为从库  
   


# <a id="aqx">MySQL的安全性考察点</a>  
##  SQL查询的安全方案
使用预处理语句防止SQL注入   

    delete from user where id = 1 or 1=1;  
写入数据库的数据要进行特殊字符的转义  
    

查询错误信息不要返回给用户，将错误记录到日志  

注意：PHP端尽量使用PDO对数据库进行相关操作，PDO拥有对预处理语句很好的支持的方法，MySQLi也有，但是可扩展性不如PDO，效率高于PDO,MySQL函数在新版本中已经趋向于淘汰，所以不建议使用，而且他还没有很好的支持预处理的方法。
## MySQL的其他安全设置  
1.定期做数据备份  
2.不给查询用户root权限，合理分配权限  
3.关闭远程访问数据库权限  
4.修改root口令，不用默认口令，使用比较复杂的口令  
5.删除多余的用户  
6.修改root用户的名称  
7.限制一般用户浏览其他库  
8.限制用户对数据文件的访问权限  

# <a id="cxyh">SQL语句查询优化考点</a>
1. __查找分析速度慢的原因__  
    - __f__ 
2. __查询优化__ 
    - __优化查询过程中的数据访问__  
    >     访问数据太多导致查询性能下降；确定应用程序是否在检索大量超过需要的数据，可能是太多行或列；确认MySQL服务器是否存在分析大量不必要的数据行。
    >     1.避免使用如下SQL语句：
    >     查询不需要的记录：使用limit解决；
    >     多表关联返回全部列：指定A.id,A.name,B.age；
    >     总是取出全部列：不要习惯性的使用select *, 会让优化器无法完成索引覆盖扫描的优化；
    >     重复查询相同的数据，可以缓存数据，下次直接读取缓存；
    >     2.是否在扫描额外的记录：
    >     使用explain来进行分析，如果发现查询需要扫描大量的数据但是只返回少量的行，可以通过如下技巧优化：
    >         使用索引覆盖扫描，把所有用的列都放到索引中，这样存储引擎不需要回表获取对应的行就可以返回结果；
    >         改变数据库和表的结构，修改数据表范式（比如根据第三范式需要多表关联，可以做冗余空间换时间）；
    >         重写SQL语句，让优化器可以以更优的方式执行查询。  
    - __优化长难的查询语句__ 
    >     1.一个复杂查询还是多个简单查询：
    >     MySQL内部每秒能扫描内存中上百万的数据，相比之下，响应数据给客户端就要慢得多（扫描快响应慢）；
    >     使用尽可能少的查询是好的，但是有时候将一个大的查询分解为多个小的查询是很有必要的
    >     2.切分查询：
    >     将一个大的查询分为多个小的相同查询；
    >     一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。
    >     3.分解关联查询：
    >     可以将一条关联语句分解成多条SQL来执行；
    >     让缓存的效率更高；
    >     执行单个查询可以减少锁的竞争；
    >     在应用层做关联可以更容易对数据库进行拆分；
    >     查询效率会有大幅的提升；
    >     较少冗余记录的查询。  
    - __优化特定类型的查询语句__  
    >     1.优化count()查询：
    >     count(*)中的*会忽略所有的列，直接统计所有的列数，因此不要使用count(列名);
    >     MyISAM中，没有任何WHERE条件的count(*)非常快；
    >     当有WHERE条件，MyISAM的count统计不一定比其他表引擎快；
    >     可以使用explain查询近似值，用近似值代替count(*)；
    >     增加汇总表；
    >     使用缓存。
    >     2.优化关联查询：
    >     确定ON或者USING子句的列上有索引；
    >     确保GROUP BY和ORDER BY 中只有一个表的列，这样MySQL才有可能使用索引。
    >     3.优化子查询：
    >     尽可能使用关联查询来代替。
    >     4.优化GROUP BY和DISTINCT
    >     这两种查询均可以使用索引来优化，是最有效的方法。
    >     关联查询中，使用标识列进行分组的效率会更高（例如主键列）；
    >     如果不需要ORDER BY，进行GROUP BY时使用ORDER BY NULL，MySQL不会再进行文件排序。
    >     WITH ROLLUP超级聚合，可以挪到应用程序处理。
    >     5.优化limit分页：
    >     limit偏移量大的时候，查询效率会低；
    >     可以记录上次查询的最大ID，下次查询时直接根据该ID来查询：
    >     select * from mytbl order by id limit 100000,10  改进后的SQL语句如下：
    >     select * from mytbl where id >= ( select id from mytbl order by id limit 100000,1 ) limit 10  注：假设id是主键索引，那么里层走的是索引，外层也是走的索引，所以性能大大提高
    >     6.优化UNION查询：
    >     UNION ALL的效率高于UNION。