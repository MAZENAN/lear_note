- [1.基础考点](#jc)
- [2.创建高性能索引考点](#sy)
- [3.SQL语句编写考点](#bx)
- [4.SQL语句查询优化考点](#cxyh)
- [5.MySQL的高可扩展和高可用考点](#gky)
- [6.MySQL的安全性考察点](#aqx)
# <a id="jc">基础考点</a>
1. __数据类型__ 
2. __MySQL基础操作__
3. __存储引擎__
4. __MySQL锁机制__
5. __事务处理__
6. __存储过程__
7. __触发器__  
8. __数据库设计三范式__  
设计数据库的时候所依据的规范  
 
(1) 第一范式：  主键、字段不能再分
    
    定义：要求有主键，数据库中不能出现重复记录，每一个字段是原子性不能再分；  
    结论：关于第一范式
    1、 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，
    2、 主键主要通常采用数值型或定长字符串表示
    3、 关于列不可再分，应根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段了； 

(2) 第二范式：非主键字段完全依赖主键  

    定义：第二范式是建立在第一范式基础之上，要求数据库中所有非主键字段完全依赖主键，不能产生部分依赖；（严格意义上说：尽量不要使用联合主键）  

    结论：一种典型的“多对多”的设计  

(3) 第三范式：

    定义：建立在第二范式基础之上，要求非主键字段不能产生传递依赖亍主键字段；  

    结论：典型的一对多
     以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键
# <a id="sy">创建高性能索引</a>
# <a id="bx">SQL语句编写考点</a>
# <a id="gky">MySQL的高可扩展和高可用考点</a>
# <a id="aqx">MySQL的安全性考察点</a>
# <a id="cxyh">SQL语句查询优化考点</a>
1. __查找分析速度慢的原因__  
    - __f__ 
2. __查询优化__ 
    - __优化查询过程中的数据访问__  
    >     访问数据太多导致查询性能下降；确定应用程序是否在检索大量超过需要的数据，可能是太多行或列；确认MySQL服务器是否存在分析大量不必要的数据行。
    >     1.避免使用如下SQL语句：
    >     查询不需要的记录：使用limit解决；
    >     多表关联返回全部列：指定A.id,A.name,B.age；
    >     总是取出全部列：不要习惯性的使用select *, 会让优化器无法完成索引覆盖扫描的优化；
    >     重复查询相同的数据，可以缓存数据，下次直接读取缓存；
    >     2.是否在扫描额外的记录：
    >     使用explain来进行分析，如果发现查询需要扫描大量的数据但是只返回少量的行，可以通过如下技巧优化：
    >         使用索引覆盖扫描，把所有用的列都放到索引中，这样存储引擎不需要回表获取对应的行就可以返回结果；
    >         改变数据库和表的结构，修改数据表范式（比如根据第三范式需要多表关联，可以做冗余空间换时间）；
    >         重写SQL语句，让优化器可以以更优的方式执行查询。  
    - __优化长难的查询语句__ 
    >     1.一个复杂查询还是多个简单查询：
    >     MySQL内部每秒能扫描内存中上百万的数据，相比之下，响应数据给客户端就要慢得多（扫描快响应慢）；
    >     使用尽可能少的查询是好的，但是有时候将一个大的查询分解为多个小的查询是很有必要的
    >     2.切分查询：
    >     将一个大的查询分为多个小的相同查询；
    >     一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。
    >     3.分解关联查询：
    >     可以将一条关联语句分解成多条SQL来执行；
    >     让缓存的效率更高；
    >     执行单个查询可以减少锁的竞争；
    >     在应用层做关联可以更容易对数据库进行拆分；
    >     查询效率会有大幅的提升；
    >     较少冗余记录的查询。  
    - __优化特定类型的查询语句__  
    >     1.优化count()查询：
    >     count(*)中的*会忽略所有的列，直接统计所有的列数，因此不要使用count(列名);
    >     MyISAM中，没有任何WHERE条件的count(*)非常快；
    >     当有WHERE条件，MyISAM的count统计不一定比其他表引擎快；
    >     可以使用explain查询近似值，用近似值代替count(*)；
    >     增加汇总表；
    >     使用缓存。
    >     2.优化关联查询：
    >     确定ON或者USING子句的列上有索引；
    >     确保GROUP BY和ORDER BY 中只有一个表的列，这样MySQL才有可能使用索引。
    >     3.优化子查询：
    >     尽可能使用关联查询来代替。
    >     4.优化GROUP BY和DISTINCT
    >     这两种查询均可以使用索引来优化，是最有效的方法。
    >     关联查询中，使用标识列进行分组的效率会更高（例如主键列）；
    >     如果不需要ORDER BY，进行GROUP BY时使用ORDER BY NULL，MySQL不会再进行文件排序。
    >     WITH ROLLUP超级聚合，可以挪到应用程序处理。
    >     5.优化limit分页：
    >     limit偏移量大的时候，查询效率会低；
    >     可以记录上次查询的最大ID，下次查询时直接根据该ID来查询：
    >     select * from mytbl order by id limit 100000,10  改进后的SQL语句如下：
    >     select * from mytbl where id >= ( select id from mytbl order by id limit 100000,1 ) limit 10  注：假设id是主键索引，那么里层走的是索引，外层也是走的索引，所以性能大大提高
    >     6.优化UNION查询：
    >     UNION ALL的效率高于UNION。