# OAuth 2.0 开放网络授权标准总纲  
## 简介  

- OAuth 2.0 是一个在全球范围得到广泛认可和应用的开放网络授权标准，基于这个标准，各个知名公司的知名产品 Google、FaceBook、GitHub、微信、QQ、微博都使用 OAuth 2.0 标准实现了授权的框架，应用于第三方登录以及其他的授权信息访问的使用场景中，在互联网上我们可以找到非常多的博客对 OAuth 2.0 进行介绍和分析，但是大都只是简单的介绍和入门，我这次会用我自己的视角来解读一下 OAuth 2.0，对于技术人员来说，OAuth 2 这是非常重要的一个网络标准，授权的使用场景也不像很多人想像的那么简单，理解了 OAuth 2.0 的使用场景和不同场景下的不同解决方案后，不管是网络 API 的开发还是将我们服务器中的用户数据或企业数据（服务）（与用户无关的数据或服务）授权给第三方的服务，你都可以搞定，对前后端分离的应用开发在整体上也会有更深入的理解。最后呢，给大家一个建议，不要总跟编程语言死磕，打基础不光是学语言那么简单，编程语言只是告诉我们如何按照语法编码；编程则是需要结合服务构建的底层技术（各种协议和规范）以及编程思想，业务场景进行工作的综合素质的考验。

## 网络授权到底是围绕什么展开的  
- OAuth 诞生时的使用场景举例:  
__小美在 A 网站 “照片仓库” 保存了非常多的照片想打印，可 A 网站却并没有提供照片编辑和相册制作的功能，而 B 网站“美图羞羞”却在相册制作领域格外风骚，但是这个时候由于 A 站和 B 站由于没有数据之间安全访问和协作的机制，小美想要完成相册的制作就很尴尬，她能采取的方案如下：__  

1. 方案一：把照片从 A 站下载下来重新上传到 B 站上。 小美觉得实在太浪费时间，效率太低，简直是对智商的一种侮辱，于是想到第二种方法。  
2. 方案二：把 A 站的账号密码告诉 B 站人员，让 B 站美图羞羞的工作人员替他操作照片的转移工作。  

效率是提升了，安全性却降低了，隐私很可能就暴露了，想到摄影专家陈师傅的遭遇，小美觉得这个方案甚至还比不上第一个解决方案，于是跟小美有同样需求的小美美们开始寻找解决方案。有需求就有商机，重利当头，头破血流，金钱可以使人癫狂，为了获得金钱人却可以理性到极致，这一次面和心不和巨头们（谷歌、雅虎、微软等）第一次坐到一起共商国是，`目的就是为 API 的访问授权提供一个统一开放的标准`，毕竟制订标准和规则这种事情对于任何一家公司来说诱惑力都实在太大了，这可是统治阶级的核心领导层才能干的事。  

在这里划下咱们的第一个重点，这个点极为重要，网络授权目的是为 API 的访问授权提供一个统一开放的标准，有了这个出发点和大前提咱们才能够真正理解 OAuth授权真正的用途，任何标准的提出都不会是简简单单为了解决某一个小需求，小问题，而是在宏观的角度上构建出解决方案，在关键细节上制订好需要共同遵守的规章。网上很多教程都是围绕 “资源授权” 对 OAuth 进行入门介绍的，导致很多人对 OAuth 的理解出现了偏差，所以在这里正本清源，咱们不要再绕着 “资源授权” 这个磨盘转了，“资源授权”只是OAuth某个使用场景下的表现形式，API 才是被 OAuth 进行授权的核心主角。API 才是不同公司的产品间相互调用服务的桥梁，资源是 API 这辆卡车携带的货物。我们使用网络 API 去请求这些资源，授予客户端（app 或者网页应用）能够通过该 API 接口获取或者操作这些资源的权限。以第三方登录为例，表面上看是我授予了某个网站或者应用访问我微信头像和用户名等资源的权限，`在技术层面则是向第三方的应用开启了 API 的访问权限`。  

## 网络授权中的不同角色如何各司其职  
- 前文书我们已经说到 `OAuth 网络授权目的是为 API 的访问授权提供一个统一开放的标准`，这篇图文咱们就看一看参与到网络授权的参与者都有哪些？核心的授权流程是如何进行的？这一次咱们从最复杂的场景出发，也就是上一篇图文当中小美的场景。在这个场景中小美的照片存放在 A 网站 “图片仓库” 中，而 B站 “美图羞羞” 需要 A 站中照片资源，所以希望 A 站能够提供小美账号下的照片以便美图羞羞可以向小美提供相册制作的服务。在这个场景下，参与者如下：  
 
1. __资源的拥有者（Resource Owner） - 用户小美__

2. __被授权的客户端 (Client Application) - B 站美图羞羞__

3. __服务提供商（HTTP Service）- A 站图片仓库__  

毕竟咱们都是技术人员，所以必要的技术名词咱们还是要慢慢引入的，如果从 UML 的方法论来说，我们正在完成从 现实世界到业务模型的转化 过程，我们也正好借着这个机会简单学习一下建模的推导过程，不求严谨，但求把里面最重要的思想传递给大家。目前我们只是简单的提取出了当前授权场景下的参与者，其授权的交互流程尚未得出。现在咱们就来看一看，被授权的客户端美图羞羞都需要获得谁的授权，它需要获得用户小美和 A 站图片仓库的联合授权，而且这个授权的过程是分两步走： 
 
1. __获得用户小美的授权__
2. __获取A站图片仓库的授权，发给B站一个`access_token`令牌__  

经过这两步授权之后，美图羞羞无需用户在A站的用户名和密码，直接拿着令牌（access token）再次到服务提供商 A 站图片仓库那里调用指定的API获取到小美的照片资源。请记住，这是一个权限有限的令牌，使用这个访问令·牌只能调用服务提供商图片仓库允许第三方客户端调用的 API 以获取相应的资源，在这里引出第 4 个核心概念，`权限范围（ scope ）`，在本例中，权限范围就是部分小美允许开放给第三方的照片资源。至此，最基本的几个核心概念咱们都凑齐了。再接下来，就到了系统分拆的阶段，我们知道参与OAuth 规则制订的多是大公司，大公司尤其讲究系统的职责划分。不光编程的时候有单一职责这个指导原则，系统进行设计的时候同样如此。于是乎，它们对服务提供商下手了，为的是更好的管理和更高的安全性，将其划分为以下两个子系统：  

1. __授权/认证服务器 ( Authorization server )__  

2. __资源服务器 ( Resource server )__  

在大公司，这是两套系统，部署在不同的服务器中，而在大部分小型公司则把他们部署在一个服务器甚至一个服务器的同一项目中。OK，接下来就该进入核心部分了，授权和认证的流程，咱们还是先贴一张图吧，这张图很多博客或教程里都出现过：

![oauth2-flow](https://github.com/MAZENAN/lear_note/blob/master/协议/img/oauth2-flow.png)  

这是一张抽象的流程图，它用最抽象的方式表达了授权和认证的过程，很多人看不懂这张图就是因为把它当作了某个场景下的具体实现流程，然而这张图只有抽象的过程，并没有具体授权和认证过程的逻辑，原来不光编程的时候玩抽象，流程图也可以玩抽象，抽象的思维无处不在，因为用好了抽象，可以帮助我们解决各类问题，不管是生活的还是工作的，利器在手，用不用在我们自己～  

OAuth在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端" 不能直接登录 "服务提供商"，只能通过授权层的授权之后才能访问用户的资源。"客户端" 所用的令牌（token），与用户的账号和密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。  "服务提供商"根据“客户端令牌”的权限范围和有效期，向"客户端"开放用户储存的资源，我们先来简单把图中核心流程梳理一下：  

__（A）用户打开客户端以后，客户端要求用户给予授权。__

__（B）用户同意给予客户端授权。__ 

__（C）客户端使用上一步获得的授权，向认证服务器申请令牌。__ 

__（D）认证服务器对客户端进行认证以后，确认无误，同意__

__（E）客户端使用令牌，向资源服务器申请获取资源。__ 

__（F）资源服务器确认令牌无误，同意向客户端开放资源。__  

__不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。__  

但是最后一句话我要进行修改，为什么呢，因为之前咱们说了这是一张抽象流程图，之所以是抽象，那就是因为到了具体场景下具体流程也会表现出“多态”的特性，授权给客户端时，授权方可能是用户和授权服务器联合授权，也可能只有授权服务器在进行授权，压根没有用户什么事。所以这里需要修改为“B是关键，`即如何向客户端进行授权”`。理解了这一点，我们才能够真正理解 OAuth2 提出的四种不同使用场景下的授权模式，在某些场景下，A、B 这两个步骤都是不存在的。上帝啊，又出现“模式”这俩字了，江湖就是如此，小帮派有小讲究，大江湖有大套路，在编程语言层面有设计模式，到了业务层面，也有更高级别的模式。有一套系列技术书籍，现在甚至都很难买齐全套了《面向模式的软件架构》，极为经典，如果你有全套的话，送我可好，我想收藏一套，以娱晚年 ～

客户端必须得到授权（authorization grant），才能获得令牌（access token），OAuth 2 提出了四种授权模式供我们在不同场景下使用：  

- 授权码模式（authorization code）  
- 简化模式（implicit）  
- 密码模式（resource owner password credentials）  
- 客户端模式（client credentials）  

但是最后咱们再次强调两个重点，这两个点切不可理解偏差，会直接影响到后面对各个授权模式的学习和理解的：  

1. OAuth 授权是围绕 API 进行的，是对需要授权的 API 设计的机制，不是针对资源进行的，也不要把那些不需要授权的 开放式 API 跟 OAuth2 授权的 API 混为一谈  

2. 文中所说的 客户端 一定要正确理解，这个客户端与平时理解的前端或者 app 客户端不是一个概念，这里的客户端某些场景下是包含自己的后端服务器的。只是因为在授权的场景下，授权方是服务的提供方，所以授权方是服务提供者，请求人家服务的第三方统一被认定为“客户端”，这是从大的调用关系上对他们的角色进行的划分。不要用日常使用的“客户端”来理解这里的客户端。  

# OAuth 2.0 开放网络授权标准详解  
## OAuth2.0 — 授权码模式详解  

![oauth2-flow](https://github.com/MAZENAN/lear_note/blob/master/协议/img/oauth2-flow.png)  

正式开始前还是请大家自行回顾一下小美的案例场景，OAuth 2.0 中的授权码模式就是专为这类使用场景而存在的，授权码模式也是 OAuth 2.0 四种授权模式中步骤最严密，授权过程最严谨的一个授权模式。上图上一篇图文中贴过的抽象授权图，接下来咱们就看一看授权码模式授权的流程图，  

![grand-code-flow](https://github.com/MAZENAN/lear_note/blob/master/协议/img/grand-code-flow.jpg)   

这里给出的图示只对授权（获取Access Token）的过程进行了“多态化”得扩展，后续其他授权模式的流程图示意图也是对这个过程的不同“多态”表示。很多人看到图基本就🤮了，但是请多给自己打打气，耐下心来学会如何去看懂这些看似非常晦涩的图，这是咱们必须要具备的一项业务能力，而且是一项基本功，是一项值得咱们去掌握的能力，更何况掌握它并不难。在这里又出现了一个新东西：

User Agent - 用户代理，在这里它代指浏览器。 用户代理和图中的 Client 其实是一个系统下的不同组成部分，这个系统在授权场景下就是“客户端”，只不过在这里又把客户端进行了职责功能的分拆，分拆为前端（User Agent）和后段（Client 指的是被授权的第三方应用的后台服务器）。  

接下来咱们看一看它整个授权步骤：

__（A）用户访问客户端，后者将前者导向认证服务器。__  

__（B）用户选择是否给予客户端授权。__  

__（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。__  

__（D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。__  

__（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。__    

单看这个简要说明的话，我们并不能真正明白到底怎么一回事，我们可以用我们最熟悉的第三方登录来辅助我们理解授权码模式授权的整个流程，我们已经知道，要想使用第三方登录，第三方的应用或网站必须得到用户和微信的联合授权才能从微信的服务器中拿到用户基本信息，要想让微信认可这个第三方的网站，首先微信得知道有这个网站的存在，而且必须以这个网站的名义向微信开放平台提交一个正式的申请，在微信开发平台进行资格申请时，我们要提供的信息包括网站的基本信息，服务范围，负责人等，然后才是授权相关的开发信息的设置。而且微信对这些信息审核非常严格，不像在github上申请那么简单，在GitHub上，申请一个第三方应用的调用GitHub API 的权限是分分钟的事。以上说的这个事是流程图中没有涉及到的一个步骤，但在实际的应用中却是非常重要的一个步骤。第三方的应用首先要得到微信的基本信任才行，审核通过后，第三方应用才有权限访问微信的授权服务器进行后续流程图中的流程。  

![wxopen](https://github.com/MAZENAN/lear_note/blob/master/协议/img/wxopen.png)  

通过申请之后，微信会分配给我们的网站一些用户后续进行授权和认证的信息，AppId 和 AppSecret。有了这两个东西之后，我们的网站就可以跟微信授权服务器进行沟通了。  

![wxopenconf](https://github.com/MAZENAN/lear_note/blob/master/协议/img/wxopenconf.png)  

有了这两个东西之后，我们的网站就可以跟微信授权服务器进行沟通了。如果是github、微博或者QQ授权，咱们申请后，也会得到类似的两个配置项，在OAuth 2.0对应的就是client_id 和 client_secret,然后咱们在把流程中的重要步骤进行详细的解释：  

A 步骤中，客户端申请认证的 URI，包含以下参数：

- response_type：表示授权类型，必选项，此处的值固定为 "code"  
- client_id：表示客户端的 ID，必选项  
- redirect_uri：表示重定向 URI ，可选项  
- scope：表示申请的权限范围，可选项  
- state：表示客户端的当前状态，这个状态值虽是一个可选项，但是对于预防 CSRF 攻击有重要的作用，请一定填写这个参数并进行严格验证，认证服务器会原封不动地返回这个值。  

![apply_code](https://github.com/MAZENAN/lear_note/blob/master/协议/img/apply_code.png)  

C 步骤中，服务器回应客户端的 URI，包含以下参数：  

- code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。
- state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。  

![response_code](https://github.com/MAZENAN/lear_note/blob/master/协议/img/response_code.png)  

D 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：  

- grant_type：表示使用的授权模式，必选项，此处的值固定为 "authorization_code"。  
- code：表示上一步获得的授权码，必选项。  
- redirect_uri：表示重定向 URI，必选项，且必须与A步骤中的该参数值保持一致。  
- client_id：表示客户端 ID，必选项。  

![apply_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/apply_token.png)  

E 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：  

- access_token：表示访问令牌，必选项。  
- token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。  
- expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。  
- refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。  
- scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 

![response_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/response_token.png)  

从上面代码可以看到 HTTP头信息中明确指定不得缓存，不得缓存是非常重要的配置项，切不可遗忘，不然很可能以后请求token的时候直接拿缓存中的 token，如果缓存中 token 早已失效的话，那就没有权限调用网络 API 获取指定的资源了。最后我们不光拿到了 access_token ,还拿到了一个叫 refresh_token 的令牌，我们必须在 access_token 过期后使用 refresh_token 在此请求一个新的 access_token,而无需再使用上面繁复的步骤获取 access_token,这样效率也会更高。这里还有一个重要的项需要说明一下，就是 scope 授权范围，scope 会指定客户端可以调取服务提供商的哪些 API 进行操作，可以是获取资源的 API，也可以是操作资源的 API。如果你实在觉得官方给出的流程示意图太过恶心的话，你可以自己一边理解一边画，我就不画了，我也暂时不扩展本篇图文了，我会在后续的视频系列当中演示一下授权服务器和客户端两方是如何进行交互的，那套视频看完之后，你就会发现原来封装第三登录的开发包其实是一件非常简单的事情，甚至可以说简单到令人发指 ～  

## OAuth2.0 — 简化授权模式详解  

本期图文咱们看一看另外一种可以解决小美问题的授权模式，Implicit Grant Type 简化模式。这种模式我不打算详细介绍，这种授权模式不通过第三方应用程序的后台服务器，直接在浏览器中向认证服务器申请令牌。它的授权流程中取消了授权码的认证过程，简化了授权流程，所以说它是一种简化的模式，所有步骤在浏览器中完成，当在浏览器中回调的网页会打开后，access token 直接在浏览器的地址栏中就能看见，这是一种不安全的模式，容易造成 access_token 的泄露。但是我之所以要写这一篇图文，除了简单介绍一下这种授权模式外，真的是因为有话要说。  

![client-side-web-app-lication-flow](https://github.com/MAZENAN/lear_note/blob/master/协议/img/client-side-web-app-lication-flow.jpg)  

那咱们先说正经的，完了之后再耍流氓，先看看第三方应用获取 Access Token 的流程：

__（A）客户端将用户导向认证服务器。__  

__（B）用户决定是否给于客户端授权。__  

__（C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向 URI"，并在 URI 的 Hash 部分包含了访问令牌。__  

__（D）浏览器将令牌发给客户端。__  


A 步骤中，客户端发出的HTTP请求，包含以下参数：  

- response_type：表示授权类型，此处的值固定为 "token"，必选项。  
- client_id：表示客户端的 ID，必选项。  
- redirect_uri：表示重定向的 URI，可选项。  
- scope：表示权限范围，可选项。  
- state：表示客户端的当前状态，为预防 CSRF 攻击，请务必设定此值并进行严格检查，认证服务器会原封不动地返回这个值。    

![simple_request_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/simple_request_token.png) 

C 步骤中，认证服务器回应客户端的URI，包含以下参数：  

- access_token：表示访问令牌，必选项。  
- token_type：表示令牌类型，该值大小写不敏感，必选项。  
- expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。  
- scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。  
- state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。   

![simple_response_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/simple_response_token.png)  

在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。浏览器自动打开 Location 中设定的网页后，我们就可以在浏览器地址栏中看到access_token。注意，在这个网址的 Hash 部分包含了令牌，在上图中示例中咱们就可以看到这个令牌。我们到了这一步就可以直接使用 Javascript 代码提取出 Access Token 发送给客户端的后台服务器了。如果你之前看过国内其他人写的 OAuth2.0 简化模式的技术博客的话，你应该会发现我写的这篇图文要简单得多，简化了很多流程和步骤，这也是我为什么要写这篇图文的原因。我们先把国内互相抄袭的版本拿过来看一下，咱们先看一看大家都再传播的一张流程图：  


![implicit1](https://github.com/MAZENAN/lear_note/blob/master/协议/img/implicit1.png)  

大家明显会发现这张图中的流程复杂了很多，A 到 C 的步骤跟我说的步骤是完全相同的，也获取到了Access Token，然后再粘贴一下之后的流程介绍  

__（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。__  

__（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。__  

__（F）浏览器执行上一步获得的脚本，提取出令牌。__  

__（G）浏览器将令牌发给客户端。__  

我最初学习 OAuth 2.0 的时候，我也是看到网上的各种博客，阮一峰的版本发的最早，对相关文档的整理和翻译得也到位，后来国内其他人写的OAuth 2.0技术博客都是照抄阮一峰的或者进行变种，但是关于简化授权模式的这部分我怎么都觉得很别扭，明明在 C 步骤已经获得了 Access Token，提取出来不就完了吗？后面的一堆流程就是请求了一段解析Access Token 的脚本代码，也并没有在安全性、效率、功能以及认证方面有任何辅助性的操作。增加的这些流程只是增加了复杂度，降低了效率，所以完全可以取消这些流程，C 步骤结束后，自己写一段 Javascrip 解析代码提取 Access Token 即可。其实并不是说其他人都错了，大家只是忠实的翻译了一下 RFC 6749 这篇技术文档中的流程罢了。  

文档和规范终究也是人写的，简化授权模式的官方文档其实犯了一个错误，把技术人员想得太笨了，就像 OAuth 1.0 版本时犯的错误一样，把流程搞得复杂到令人发指，最后大家都不怎么买账，直到后来 OAuth 2.0 版本极大简化了授权机制和流程后，才得到广泛的认可和应用，但是这个模式 OAuth 2.0 还是把它搞复杂了，多了后续那些不必要的流程，如果有 OAuth 3.0，我想肯定不会再这么设计了。  

## OAuth2.0 — 密码授权模式详解  
有心栽花花不开，无心插柳柳成荫。本期图文咱们看一看表面上很鸡肋，曾经也非常鸡肋，后来应用非常广泛的一种授权模式：密码授权模式。密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。 在这种模式中，用户必须把自己的密码给客户端。  

这个模式肯定就不适合小美使用了，因为她要把自己“图片仓库”的账号和密码提供给“美图羞羞”，这么弱智的事情用户肯定不会去做，我们不主动泄露自己的个人信息天天都能接到无数的垃圾短信和骚扰电话，更别说上赶子把自己的账号密码给别人了，哪怕再信任也不行，我们被公司或个人出卖个人信息出卖的还少吗？密码模式既然不适合这种场景，那它的使用场景是什么呢？如果要提供账号密码的话，我们通常都会提供给谁呢？这个使用场景似乎很熟悉对不对？是的，我们已经很接近答案了：“自家的客户端调用自家的服务器的 API 请求自家服务器中资源”。我们手机里的应用，前后端分离的单页应用都可以采取这种授权模式。本来密码模式设计之处是为了兼容那个让人想吐的 “OAuth 1.0” ，没想到最后却在移动互联网时代老树发新芽，重新绽放了青春。   

![resource-owner-flow](https://github.com/MAZENAN/lear_note/blob/master/协议/img/resource-owner-flow.jpg)  

密码模式的授权步骤如下：  

__（A）用户向客户端提供用户名和密码。__    

__（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。__  

__（C）认证服务器确认无误后，向客户端提供访问令牌。__  

这是大家熟知的流程，也是大家都操作过的流程，这个模式也最容易理解，授权的过程也最简单，所以简单的事情咱们简单处理，不浪费过多口舌。简单了解一下相关参数即可：  

B 步骤中，客户端发出的HTTP请求，包含以下参数：
    
- grant_type：表示授权类型，此处的值固定为 "password"，必选项。  
- username：表示用户名，必选项。  
- password：表示用户的密码，必选项。  
- scope：表示权限范围，可选项。  

![pwd_request_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/pwd_request_token.png)  

C 步骤中，认证服务器向客户端发送访问令牌：  

![pwd_response_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/pwd_response_token.png)  

这个返回结果大家应该是非常熟悉了，跟之前授权码那部分的内容一样，不再赘述。密码模式中有一条重要的规则就是所有流程中不得保存用户的用户名和密码，但是呢，这只是一种幻想性的建议而已。  

## OAuth2.0 — 客户端模式详解   

终于到了最后一个模式的介绍，这个模式就是客户端模式（Client Credentials Grant）。客户端模式指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。从这个简要的描述中我们就可以知道这种授权场景下，不需要普通用户的参与，客户端从授权服务器获取到 Access Token 令牌后，使用这个令牌从资源服务器获取的资源也都是跟用户没有关联性质的数据。所以呢，这种授权模式应用的场景是 B2B 的服务授权调用，属于企业间数据授权和交互的范畴。对这个模式做个简单了解即可，为什么这么说呢，因为企业间 B2B 的服务授权可采取的方式很多，而本期图文介绍的客户端模式只是其中一种而已，这个模式大家用小脑转个弯就能理解，没有扩展开来的必要了。  

令牌颁发的步骤如下：

__（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。__  

__（B）认证服务器确认无误后，向客户端提供访问令牌。__   

A 步骤中，客户端发出的HTTP请求，包含以下参数：  

- grant_type：表示授权类型，此处的值固定为"clientcredentials"，必选项。
- scope：表示权限范围，可选项。  

![client_request_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/client_request_token.png)  

B步骤认证服务器向客户端发送访问令牌：  

![client_response_token](https://github.com/MAZENAN/lear_note/blob/master/协议/img/client_response_token.png)  

